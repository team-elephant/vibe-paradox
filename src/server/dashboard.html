<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>VIBE PARADOX — LIVE</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;600&display=swap');

:root {
  --bg-primary: #0a0a0a;
  --bg-secondary: #111111;
  --bg-panel: #0d0d0d;
  --border: #222222;
  --text-primary: #00ff88;
  --text-secondary: #668866;
  --color-fighter: #44aaff;
  --color-merchant: #00ff88;
  --color-monster: #ff4444;
  --color-npc: #666666;
  --color-behemoth: #aa44ff;
  --color-gold: #ffaa00;
  --color-combat: #ff2222;
  --color-trade: #44aaff;
  --color-evolution: #ff44ff;
  --color-resource: #00aa44;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  font-family: 'JetBrains Mono', 'Courier New', monospace;
}

body {
  background: var(--bg-primary);
  color: var(--text-primary);
  overflow: hidden;
  height: 100vh;
}

/* === LOGIN SCREEN === */
#login-screen {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100vh;
  flex-direction: column;
}
#login-box {
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  padding: 32px 40px;
  max-width: 380px;
  width: 90%;
}
#login-box h1 {
  font-size: 16px;
  letter-spacing: 3px;
  margin-bottom: 24px;
  text-align: center;
  font-weight: 600;
}
#login-box .field {
  margin-bottom: 14px;
}
#login-box label {
  display: block;
  font-size: 11px;
  color: var(--text-secondary);
  margin-bottom: 4px;
  text-transform: uppercase;
  letter-spacing: 1px;
}
#login-box input {
  width: 100%;
  padding: 8px 10px;
  background: var(--bg-primary);
  border: 1px solid var(--border);
  color: var(--text-primary);
  font-family: inherit;
  font-size: 13px;
  outline: none;
}
#login-box input:focus {
  border-color: var(--text-primary);
}
#login-box .buttons {
  display: flex;
  gap: 8px;
  margin-top: 20px;
}
#login-box button {
  flex: 1;
  padding: 8px 0;
  background: var(--bg-primary);
  border: 1px solid var(--border);
  color: var(--text-primary);
  font-family: inherit;
  font-size: 12px;
  cursor: pointer;
  letter-spacing: 1px;
}
#login-box button:hover {
  background: var(--bg-secondary);
  border-color: var(--text-primary);
}
#login-box button.primary {
  background: #0a2a1a;
  border-color: var(--text-primary);
}
#login-error {
  color: var(--color-combat);
  font-size: 11px;
  margin-top: 10px;
  min-height: 16px;
}
.legacy-link {
  text-align: center;
  margin-top: 16px;
  font-size: 10px;
  color: var(--text-secondary);
}

/* === MAIN APP === */
#app {
  display: none;
  grid-template-rows: 40px 1fr 200px;
  grid-template-columns: 1fr 320px;
  height: 100vh;
  gap: 1px;
  background: var(--border);
}
#app.visible {
  display: grid;
}

/* === HEADER === */
#header {
  grid-column: 1 / -1;
  background: var(--bg-secondary);
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 16px;
  font-size: 13px;
}
#header .title {
  font-weight: 600;
  letter-spacing: 2px;
  font-size: 14px;
}
#header .status {
  display: flex;
  align-items: center;
  gap: 12px;
  color: var(--text-secondary);
}
#header .status .dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: #ff4444;
}
#header .status .dot.connected {
  background: var(--text-primary);
  box-shadow: 0 0 6px var(--text-primary);
}
#header .user-info {
  display: flex;
  align-items: center;
  gap: 12px;
  font-size: 11px;
  color: var(--text-secondary);
}
#header .user-info .username {
  color: var(--text-primary);
}
#header .user-info button {
  background: none;
  border: 1px solid var(--border);
  color: var(--text-secondary);
  font-family: inherit;
  font-size: 10px;
  padding: 2px 8px;
  cursor: pointer;
}
#header .user-info button:hover {
  border-color: var(--text-primary);
  color: var(--text-primary);
}

/* === CANVAS === */
#map-panel {
  background: var(--bg-panel);
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
}
#map-panel canvas {
  display: block;
}
/* scanline overlay */
#map-panel::after {
  content: '';
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  background: repeating-linear-gradient(
    0deg,
    transparent,
    transparent 2px,
    rgba(0,0,0,0.04) 2px,
    rgba(0,0,0,0.04) 4px
  );
  pointer-events: none;
}

/* tooltip */
#tooltip {
  display: none;
  position: absolute;
  background: rgba(10,10,10,0.95);
  border: 1px solid var(--border);
  padding: 8px 10px;
  font-size: 11px;
  color: var(--text-primary);
  pointer-events: none;
  z-index: 10;
  white-space: pre;
  line-height: 1.5;
  max-width: 280px;
}

/* === RIGHT PANEL === */
#right-panel {
  background: var(--bg-panel);
  display: flex;
  flex-direction: column;
  overflow: hidden;
}
#stats-panel {
  padding: 10px 12px;
  border-bottom: 1px solid var(--border);
  font-size: 12px;
  flex-shrink: 0;
}
#stats-panel h3 {
  color: var(--text-secondary);
  font-size: 11px;
  font-weight: 400;
  letter-spacing: 1px;
  margin-bottom: 6px;
  text-transform: uppercase;
}
#stats-panel .stat-row {
  display: flex;
  justify-content: space-between;
  margin-bottom: 2px;
}
#stats-panel .stat-label {
  color: var(--text-secondary);
}

/* === TAB BAR === */
.tab-bar {
  display: flex;
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
}
.tab-bar button {
  flex: 1;
  padding: 6px 0;
  background: none;
  border: none;
  border-bottom: 2px solid transparent;
  color: var(--text-secondary);
  font-family: inherit;
  font-size: 10px;
  letter-spacing: 1px;
  text-transform: uppercase;
  cursor: pointer;
}
.tab-bar button:hover {
  color: var(--text-primary);
}
.tab-bar button.active {
  color: var(--text-primary);
  border-bottom-color: var(--text-primary);
}

/* === AGENTS TAB === */
#agents-panel {
  flex: 1;
  overflow-y: auto;
  padding: 0;
}
#agents-panel h3 {
  color: var(--text-secondary);
  font-size: 11px;
  font-weight: 400;
  letter-spacing: 1px;
  padding: 8px 12px 4px;
  text-transform: uppercase;
  position: sticky;
  top: 0;
  background: var(--bg-panel);
}
.agent-card {
  padding: 6px 12px;
  border-bottom: 1px solid var(--border);
  font-size: 11px;
  cursor: pointer;
  transition: background 0.15s;
}
.agent-card:hover {
  background: var(--bg-secondary);
}
.agent-card.selected {
  background: #1a1a1a;
  border-left: 2px solid var(--text-primary);
}
.agent-card .agent-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 3px;
}
.agent-card .agent-name {
  font-weight: 600;
}
.agent-card .agent-status {
  font-size: 10px;
  padding: 1px 5px;
  border-radius: 2px;
}
.agent-card .agent-status.idle { color: var(--text-primary); }
.agent-card .agent-status.moving { color: var(--color-gold); }
.agent-card .agent-status.fighting { color: var(--color-combat); }
.agent-card .agent-status.gathering { color: var(--color-fighter); }
.agent-card .agent-status.dead { color: #555; }
.agent-card .agent-status.crafting { color: var(--color-trade); }
.agent-card .agent-status.climbing { color: var(--color-behemoth); }
.agent-card .agent-status.trading { color: var(--color-trade); }

.agent-card .agent-details {
  color: var(--text-secondary);
  font-size: 10px;
  line-height: 1.6;
}
.health-bar {
  display: inline-block;
  font-size: 10px;
  letter-spacing: -1px;
}
.health-bar .filled { color: var(--text-primary); }
.health-bar .empty { color: #333; }

/* agent control buttons */
.agent-controls {
  display: flex;
  gap: 4px;
  margin-top: 4px;
}
.agent-controls button {
  padding: 2px 8px;
  background: var(--bg-primary);
  border: 1px solid var(--border);
  color: var(--text-secondary);
  font-family: inherit;
  font-size: 10px;
  cursor: pointer;
}
.agent-controls button:hover {
  border-color: var(--text-primary);
  color: var(--text-primary);
}
.agent-controls button.danger:hover {
  border-color: var(--color-combat);
  color: var(--color-combat);
}

/* spawn form */
#spawn-form {
  padding: 8px 12px;
  border-top: 1px solid var(--border);
  font-size: 11px;
  flex-shrink: 0;
}
#spawn-form h4 {
  color: var(--text-secondary);
  font-size: 10px;
  font-weight: 400;
  letter-spacing: 1px;
  text-transform: uppercase;
  margin-bottom: 6px;
}
#spawn-form .field {
  margin-bottom: 6px;
  display: flex;
  align-items: center;
  gap: 6px;
}
#spawn-form label {
  font-size: 10px;
  color: var(--text-secondary);
  width: 40px;
  flex-shrink: 0;
}
#spawn-form input, #spawn-form select {
  flex: 1;
  padding: 4px 6px;
  background: var(--bg-primary);
  border: 1px solid var(--border);
  color: var(--text-primary);
  font-family: inherit;
  font-size: 11px;
  outline: none;
}
#spawn-form input:focus, #spawn-form select:focus {
  border-color: var(--text-primary);
}
#spawn-form select option {
  background: var(--bg-primary);
}
#spawn-form button {
  width: 100%;
  padding: 5px 0;
  background: #0a2a1a;
  border: 1px solid var(--text-primary);
  color: var(--text-primary);
  font-family: inherit;
  font-size: 11px;
  cursor: pointer;
  letter-spacing: 1px;
  margin-top: 4px;
}
#spawn-form button:hover {
  background: #0f3f2a;
}
#spawn-form button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}
#spawn-msg {
  font-size: 10px;
  margin-top: 4px;
  min-height: 14px;
}
#spawn-msg.error { color: var(--color-combat); }
#spawn-msg.success { color: var(--text-primary); }

/* === COST TAB === */
#cost-panel {
  display: none;
  flex: 1;
  overflow-y: auto;
  padding: 10px 12px;
  font-size: 11px;
}
#cost-panel h3 {
  color: var(--text-secondary);
  font-size: 11px;
  font-weight: 400;
  letter-spacing: 1px;
  margin-bottom: 8px;
  text-transform: uppercase;
}
#cost-panel .cost-row {
  display: flex;
  justify-content: space-between;
  margin-bottom: 4px;
}
#cost-panel .cost-label {
  color: var(--text-secondary);
}
#cost-panel .cost-value {
  color: var(--text-primary);
}
#cost-panel .cost-divider {
  border-top: 1px solid var(--border);
  margin: 8px 0;
}

/* === SETTINGS TAB === */
#settings-panel {
  display: none;
  flex: 1;
  overflow-y: auto;
  padding: 10px 12px;
  font-size: 11px;
}
#settings-panel h3 {
  color: var(--text-secondary);
  font-size: 11px;
  font-weight: 400;
  letter-spacing: 1px;
  margin-bottom: 8px;
  text-transform: uppercase;
}
#settings-panel p {
  color: var(--text-secondary);
  font-size: 10px;
  line-height: 1.5;
  margin-bottom: 10px;
}
#settings-panel .field {
  margin-bottom: 10px;
}
#settings-panel label {
  display: block;
  font-size: 10px;
  color: var(--text-secondary);
  margin-bottom: 4px;
  text-transform: uppercase;
  letter-spacing: 1px;
}
#settings-panel input {
  width: 100%;
  padding: 6px 8px;
  background: var(--bg-primary);
  border: 1px solid var(--border);
  color: var(--text-primary);
  font-family: inherit;
  font-size: 11px;
  outline: none;
}
#settings-panel input:focus {
  border-color: var(--text-primary);
}
#settings-panel button {
  padding: 6px 16px;
  background: #0a2a1a;
  border: 1px solid var(--text-primary);
  color: var(--text-primary);
  font-family: inherit;
  font-size: 11px;
  cursor: pointer;
}
#settings-panel button:hover {
  background: #0f3f2a;
}
#api-key-msg {
  font-size: 10px;
  margin-top: 6px;
  min-height: 14px;
}
#api-key-msg.error { color: var(--color-combat); }
#api-key-msg.success { color: var(--text-primary); }
.api-key-status {
  margin-bottom: 8px;
  font-size: 10px;
}
.api-key-status .set { color: var(--text-primary); }
.api-key-status .not-set { color: var(--color-gold); }

/* === EVENT FEED === */
#event-feed {
  grid-column: 1 / -1;
  background: var(--bg-panel);
  overflow-y: auto;
  padding: 8px 12px;
  font-size: 11px;
  border-top: 1px solid var(--border);
}
#event-feed h3 {
  color: var(--text-secondary);
  font-size: 11px;
  font-weight: 400;
  letter-spacing: 1px;
  margin-bottom: 6px;
  text-transform: uppercase;
  position: sticky;
  top: 0;
  background: var(--bg-panel);
  padding-bottom: 4px;
}
.event-line {
  margin-bottom: 2px;
  line-height: 1.5;
  animation: fadeIn 0.3s ease-in;
}
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(4px); }
  to   { opacity: 1; transform: translateY(0); }
}
.event-tick {
  color: var(--text-secondary);
}
.event-combat   { color: var(--color-combat); }
.event-resource  { color: var(--color-resource); }
.event-trade     { color: var(--color-trade); }
.event-evolution { color: var(--color-evolution); }
.event-death     { color: #ff6666; }
.event-behemoth  { color: var(--color-behemoth); }
.event-chat      { color: var(--text-secondary); }
.event-alliance  { color: #66ffff; }
.event-spawn     { color: var(--color-resource); }

/* scrollbar */
::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: var(--bg-primary); }
::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }
</style>
</head>
<body>

<!-- LOGIN SCREEN -->
<div id="login-screen">
  <div id="login-box">
    <h1>VIBE PARADOX</h1>
    <div class="field">
      <label for="login-username">Username</label>
      <input type="text" id="login-username" autocomplete="username" autofocus>
    </div>
    <div class="field">
      <label for="login-password">Password</label>
      <input type="password" id="login-password" autocomplete="current-password">
    </div>
    <div class="buttons">
      <button onclick="doLogin()" class="primary">Login</button>
      <button onclick="doSignup()">Sign Up</button>
    </div>
    <div id="login-error"></div>
  </div>
  <div class="legacy-link">
    <span id="legacy-hint" style="display:none">Admin key detected — connecting...</span>
  </div>
</div>

<!-- MAIN APP -->
<div id="app">
  <div id="header">
    <span class="title">VIBE PARADOX &mdash; LIVE</span>
    <div class="user-info">
      <span>user: <span class="username" id="display-username"></span></span>
      <span id="admin-badge" style="display:none;color:var(--color-gold)">[admin]</span>
      <button onclick="doLogout()">logout</button>
    </div>
    <span class="status">
      <span id="tick-display">Tick: 0</span>
      <span class="dot" id="conn-dot"></span>
      <span id="conn-label">disconnected</span>
    </span>
  </div>

  <div id="map-panel">
    <canvas id="world-canvas"></canvas>
    <div id="tooltip"></div>
  </div>

  <div id="right-panel">
    <div id="stats-panel">
      <h3>WORLD STATS</h3>
      <div id="stats-content"></div>
    </div>

    <div class="tab-bar">
      <button class="active" onclick="switchTab('agents')">Agents</button>
      <button onclick="switchTab('cost')">Cost</button>
      <button onclick="switchTab('settings')">Settings</button>
    </div>

    <div id="agents-panel">
      <h3 id="agents-header">MY AGENTS</h3>
      <div id="agents-list"></div>
    </div>

    <div id="cost-panel">
      <h3>COST OVERVIEW</h3>
      <div id="cost-content"></div>
    </div>

    <div id="settings-panel">
      <h3>API KEY</h3>
      <p>To run AI agents, you need an Anthropic API key. Your key is encrypted at rest and only used to power your agents.</p>
      <div class="api-key-status" id="api-key-status"></div>
      <div class="field">
        <label for="api-key-input">API Key</label>
        <input type="password" id="api-key-input" placeholder="sk-ant-...">
      </div>
      <button onclick="saveApiKey()">Save Key</button>
      <div id="api-key-msg"></div>
    </div>

    <div id="spawn-form">
      <h4>Spawn Agent</h4>
      <div class="field">
        <label>Role</label>
        <select id="spawn-role">
          <option value="fighter">Fighter</option>
          <option value="merchant">Merchant</option>
          <option value="monster">Monster</option>
        </select>
      </div>
      <div class="field">
        <label>Name</label>
        <input type="text" id="spawn-name" placeholder="Agent name" maxlength="32">
      </div>
      <button onclick="spawnAgent()" id="spawn-btn">Create &amp; Start</button>
      <div id="spawn-msg"></div>
    </div>
  </div>

  <div id="event-feed">
    <h3>EVENT FEED</h3>
    <div id="events-list"></div>
  </div>
</div>

<script>
// === HTML ESCAPE (prevent XSS from agent names, chat messages, etc.) ===
function esc(str) {
  if (typeof str !== 'string') return String(str);
  return str
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

// === AUTH STATE (in-memory, not localStorage) ===
let authToken = null;
let currentUser = null;
let isGodMode = false;

// === APP STATE ===
let state = null;
let selectedAgentId = null;
let hoveredAgent = null;
let mouseX = 0, mouseY = 0;
const eventLog = [];
const MAX_EVENTS = 100;
let myAgents = [];  // user's agents from API
let activeTab = 'agents';

// === CHECK FOR LEGACY ?key= AUTH ===
(function checkLegacyKey() {
  const params = new URLSearchParams(location.search);
  const key = params.get('key');
  if (key) {
    isGodMode = true;
    authToken = null;
    document.getElementById('legacy-hint').style.display = 'block';
    showApp();
    connectWs();
  }
})();

// === LOGIN / SIGNUP ===
async function doLogin() {
  const username = document.getElementById('login-username').value.trim();
  const password = document.getElementById('login-password').value;
  if (!username || !password) {
    showLoginError('Username and password required');
    return;
  }
  try {
    const res = await fetch('/api/auth/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ username, password }),
    });
    const data = await res.json();
    if (!res.ok) {
      showLoginError(data.error || 'Login failed');
      return;
    }
    authToken = data.token;
    currentUser = data.user;
    showApp();
    connectWs();
    fetchMyAgents();
  } catch (e) {
    showLoginError('Connection error');
  }
}

async function doSignup() {
  const username = document.getElementById('login-username').value.trim();
  const password = document.getElementById('login-password').value;
  if (!username || !password) {
    showLoginError('Username and password required');
    return;
  }
  try {
    const res = await fetch('/api/auth/signup', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ username, password }),
    });
    const data = await res.json();
    if (!res.ok) {
      showLoginError(data.error || 'Signup failed');
      return;
    }
    authToken = data.token;
    currentUser = data.user;
    showApp();
    connectWs();
    fetchMyAgents();
  } catch (e) {
    showLoginError('Connection error');
  }
}

async function doLogout() {
  if (authToken) {
    try {
      await fetch('/api/auth/logout', {
        method: 'POST',
        headers: { 'Authorization': 'Bearer ' + authToken },
      });
    } catch {}
  }
  authToken = null;
  currentUser = null;
  isGodMode = false;
  if (ws) ws.close();
  showLogin();
}

function showLoginError(msg) {
  document.getElementById('login-error').textContent = msg;
}

function showApp() {
  document.getElementById('login-screen').style.display = 'none';
  document.getElementById('app').classList.add('visible');
  if (currentUser) {
    document.getElementById('display-username').textContent = currentUser.username;
    if (currentUser.is_admin) {
      document.getElementById('admin-badge').style.display = '';
    }
  } else if (isGodMode) {
    document.getElementById('display-username').textContent = 'admin (legacy)';
    document.getElementById('admin-badge').style.display = '';
  }
  resizeCanvas();
  requestAnimationFrame(render);
}

function showLogin() {
  document.getElementById('login-screen').style.display = 'flex';
  document.getElementById('app').classList.remove('visible');
  document.getElementById('login-error').textContent = '';
  document.getElementById('login-password').value = '';
}

// === PASSWORD ENTER KEY ===
document.getElementById('login-password').addEventListener('keydown', function(e) {
  if (e.key === 'Enter') doLogin();
});
document.getElementById('login-username').addEventListener('keydown', function(e) {
  if (e.key === 'Enter') document.getElementById('login-password').focus();
});

// === AGENT API ===
function authHeaders() {
  const h = { 'Content-Type': 'application/json' };
  if (authToken) h['Authorization'] = 'Bearer ' + authToken;
  return h;
}

async function fetchMyAgents() {
  if (!authToken) return;
  try {
    const res = await fetch('/api/agents', { headers: authHeaders() });
    if (res.ok) {
      const data = await res.json();
      myAgents = data.agents || [];
      updateAgentList();
      updateCostPanel();
      updateApiKeyStatus();
    }
  } catch {}
}

async function spawnAgent() {
  const name = document.getElementById('spawn-name').value.trim();
  const role = document.getElementById('spawn-role').value;
  const msgEl = document.getElementById('spawn-msg');

  if (!name) {
    msgEl.textContent = 'Name is required';
    msgEl.className = 'error';
    return;
  }

  document.getElementById('spawn-btn').disabled = true;
  msgEl.textContent = 'Creating...';
  msgEl.className = '';

  try {
    // Step 1: create agent
    const createRes = await fetch('/api/agents', {
      method: 'POST',
      headers: authHeaders(),
      body: JSON.stringify({ name, role }),
    });
    const createData = await createRes.json();
    if (!createRes.ok) {
      msgEl.textContent = createData.error || 'Create failed';
      msgEl.className = 'error';
      document.getElementById('spawn-btn').disabled = false;
      return;
    }

    // Step 2: start agent
    const agentId = createData.agent.id;
    const startRes = await fetch('/api/agents/' + agentId + '/start', {
      method: 'POST',
      headers: authHeaders(),
    });
    const startData = await startRes.json();
    if (!startRes.ok) {
      msgEl.textContent = 'Created but start failed: ' + (startData.error || '');
      msgEl.className = 'error';
    } else {
      msgEl.textContent = 'Agent spawned!';
      msgEl.className = 'success';
      document.getElementById('spawn-name').value = '';
    }

    fetchMyAgents();
  } catch (e) {
    msgEl.textContent = 'Connection error';
    msgEl.className = 'error';
  }
  document.getElementById('spawn-btn').disabled = false;
}

async function startAgent(agentId) {
  try {
    const res = await fetch('/api/agents/' + agentId + '/start', {
      method: 'POST',
      headers: authHeaders(),
    });
    if (!res.ok) {
      const data = await res.json();
      alert(data.error || 'Start failed');
    }
    fetchMyAgents();
  } catch {}
}

async function stopAgent(agentId) {
  try {
    const res = await fetch('/api/agents/' + agentId + '/stop', {
      method: 'POST',
      headers: authHeaders(),
    });
    if (!res.ok) {
      const data = await res.json();
      alert(data.error || 'Stop failed');
    }
    fetchMyAgents();
  } catch {}
}

async function deleteAgent(agentId) {
  if (!confirm('Delete this agent? This cannot be undone.')) return;
  try {
    const res = await fetch('/api/agents/' + agentId, {
      method: 'DELETE',
      headers: authHeaders(),
    });
    if (!res.ok) {
      const data = await res.json();
      alert(data.error || 'Delete failed');
    }
    fetchMyAgents();
  } catch {}
}

// === API KEY ===
function updateApiKeyStatus() {
  const el = document.getElementById('api-key-status');
  if (!currentUser) {
    el.innerHTML = '';
    return;
  }
  if (currentUser.has_api_key) {
    el.innerHTML = '<span class="set">API key is set</span>';
  } else {
    el.innerHTML = '<span class="not-set">No API key configured — agents cannot start without one</span>';
  }
}

async function saveApiKey() {
  const key = document.getElementById('api-key-input').value.trim();
  const msgEl = document.getElementById('api-key-msg');
  if (!key) {
    msgEl.textContent = 'Enter an API key';
    msgEl.className = 'error';
    return;
  }
  try {
    const res = await fetch('/api/user/settings', {
      method: 'PUT',
      headers: authHeaders(),
      body: JSON.stringify({ api_key: key }),
    });
    const data = await res.json();
    if (!res.ok) {
      msgEl.textContent = data.error || 'Failed to save';
      msgEl.className = 'error';
      return;
    }
    msgEl.textContent = 'API key saved';
    msgEl.className = 'success';
    document.getElementById('api-key-input').value = '';
    if (currentUser) currentUser.has_api_key = true;
    updateApiKeyStatus();
  } catch {
    msgEl.textContent = 'Connection error';
    msgEl.className = 'error';
  }
}

// === TABS ===
function switchTab(tab) {
  activeTab = tab;
  document.querySelectorAll('.tab-bar button').forEach(b => b.classList.remove('active'));
  document.querySelectorAll('.tab-bar button').forEach(b => {
    if (b.textContent.toLowerCase() === tab) b.classList.add('active');
  });
  document.getElementById('agents-panel').style.display = tab === 'agents' ? '' : 'none';
  document.getElementById('cost-panel').style.display = tab === 'cost' ? '' : 'none';
  document.getElementById('settings-panel').style.display = tab === 'settings' ? '' : 'none';
  document.getElementById('spawn-form').style.display = tab === 'agents' && !isGodMode ? '' : 'none';
}

// === COST PANEL ===
function updateCostPanel() {
  const el = document.getElementById('cost-content');
  if (!myAgents.length) {
    el.innerHTML = '<div style="color:var(--text-secondary)">No agents yet</div>';
    return;
  }
  let totalCost = 0;
  let totalCalls = 0;
  const perAgent = myAgents.map(a => {
    totalCost += a.total_cost || 0;
    totalCalls += a.total_llm_calls || 0;
    return `<div class="cost-row"><span class="cost-label">${esc(a.agent_name)}</span><span class="cost-value">$${(a.total_cost || 0).toFixed(4)} (${a.total_llm_calls || 0} calls)</span></div>`;
  });

  el.innerHTML = [
    `<div class="cost-row"><span class="cost-label">Total cost</span><span class="cost-value">$${totalCost.toFixed(4)}</span></div>`,
    `<div class="cost-row"><span class="cost-label">Total LLM calls</span><span class="cost-value">${totalCalls}</span></div>`,
    '<div class="cost-divider"></div>',
    '<h3>PER AGENT</h3>',
    ...perAgent,
  ].join('');
}

// === CANVAS SETUP ===
const canvas = document.getElementById('world-canvas');
const ctx = canvas.getContext('2d');
const WORLD_SIZE = 1000;
let canvasSize = 600;
let scale = canvasSize / WORLD_SIZE;

function resizeCanvas() {
  const panel = document.getElementById('map-panel');
  if (!panel) return;
  const s = Math.min(panel.clientWidth, panel.clientHeight) - 8;
  canvasSize = Math.max(300, s);
  canvas.width = canvasSize;
  canvas.height = canvasSize;
  scale = canvasSize / WORLD_SIZE;
}
window.addEventListener('resize', resizeCanvas);

function worldToCanvas(x, y) {
  return [x * scale, y * scale];
}

// === COLORS ===
const ROLE_COLORS = {
  fighter: '#44aaff',
  merchant: '#00ff88',
  monster: '#ff4444',
};
const NPC_COLOR = '#666666';
const BEHEMOTH_COLOR = '#aa44ff';
const TREE_COLOR = '#1a5c1a';
const GOLD_COLOR = '#ffaa00';
const SAPLING_COLOR = '#88ff88';

// === RENDERING ===
let animFrame = 0;

function render() {
  animFrame++;
  ctx.fillStyle = '#0a0a0a';
  ctx.fillRect(0, 0, canvasSize, canvasSize);

  // grid lines every 100 world units
  ctx.strokeStyle = '#161616';
  ctx.lineWidth = 0.5;
  for (let i = 0; i <= WORLD_SIZE; i += 100) {
    const p = i * scale;
    ctx.beginPath(); ctx.moveTo(p, 0); ctx.lineTo(p, canvasSize); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0, p); ctx.lineTo(canvasSize, p); ctx.stroke();
  }

  if (!state) {
    ctx.fillStyle = '#333';
    ctx.font = '14px JetBrains Mono';
    ctx.textAlign = 'center';
    ctx.fillText('Waiting for server...', canvasSize / 2, canvasSize / 2);
    requestAnimationFrame(render);
    return;
  }

  // safe zone
  const [sx, sy] = worldToCanvas(500, 500);
  const sr = 100 * scale;
  ctx.strokeStyle = 'rgba(255,255,255,0.08)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.arc(sx, sy, sr, 0, Math.PI * 2);
  ctx.stroke();
  ctx.fillStyle = 'rgba(255,255,255,0.01)';
  ctx.fill();

  // resources
  for (const r of state.resources) {
    const [rx, ry] = worldToCanvas(r.position.x, r.position.y);
    if (r.type === 'tree') {
      ctx.fillStyle = TREE_COLOR;
      ctx.fillRect(rx - 1, ry - 1, 2, 2);
    } else if (r.type === 'gold_vein') {
      ctx.fillStyle = GOLD_COLOR;
      ctx.beginPath();
      ctx.arc(rx, ry, 2 * scale / (canvasSize / 600) || 2, 0, Math.PI * 2);
      ctx.fill();
    } else if (r.type === 'sapling') {
      ctx.fillStyle = SAPLING_COLOR;
      ctx.fillRect(rx - 1, ry - 1, 2, 2);
    }
  }

  // NPC monsters
  for (const npc of state.npcMonsters) {
    const [nx, ny] = worldToCanvas(npc.position.x, npc.position.y);
    ctx.fillStyle = NPC_COLOR;
    ctx.beginPath();
    ctx.arc(nx, ny, 3, 0, Math.PI * 2);
    ctx.fill();
  }

  // behemoths
  for (const b of state.behemoths) {
    const [bx, by] = worldToCanvas(b.position.x, b.position.y);
    ctx.fillStyle = BEHEMOTH_COLOR;
    const pulse = b.status === 'unconscious' ? 10 + Math.sin(animFrame * 0.1) * 3 : 10;
    ctx.beginPath();
    ctx.arc(bx, by, pulse, 0, Math.PI * 2);
    ctx.globalAlpha = b.status === 'unconscious' ? 0.5 + Math.sin(animFrame * 0.1) * 0.3 : 0.8;
    ctx.fill();
    ctx.globalAlpha = 1;
    // label
    ctx.fillStyle = BEHEMOTH_COLOR;
    ctx.font = '9px JetBrains Mono';
    ctx.textAlign = 'center';
    ctx.fillText(b.type, bx, by - pulse - 3);
  }

  // combat lines
  const fightingAgents = state.agents.filter(a => a.status === 'fighting');
  for (const a of fightingAgents) {
    let closest = null;
    let closestDist = Infinity;

    for (const npc of state.npcMonsters) {
      if (npc.status === 'attack' || npc.status === 'chase') {
        const d = Math.hypot(a.position.x - npc.position.x, a.position.y - npc.position.y);
        if (d < closestDist && d < 20) { closestDist = d; closest = npc; }
      }
    }
    for (const other of state.agents) {
      if (other.id !== a.id && other.status === 'fighting') {
        const d = Math.hypot(a.position.x - other.position.x, a.position.y - other.position.y);
        if (d < closestDist && d < 20) { closestDist = d; closest = other; }
      }
    }

    if (closest) {
      const [ax, ay] = worldToCanvas(a.position.x, a.position.y);
      const [tx, ty] = worldToCanvas(closest.position.x, closest.position.y);
      ctx.strokeStyle = 'rgba(255,34,34,0.5)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(ax, ay);
      ctx.lineTo(tx, ty);
      ctx.stroke();
    }
  }

  // agents
  for (const agent of state.agents) {
    const [ax, ay] = worldToCanvas(agent.position.x, agent.position.y);
    const color = ROLE_COLORS[agent.role] || '#fff';
    let radius = 4;
    if (agent.role === 'monster') {
      radius = agent.evolutionStage === 1 ? 5 :
               agent.evolutionStage === 2 ? 6 :
               agent.evolutionStage === 3 ? 8 : 12;
    }

    // movement line
    if (agent.destination) {
      const [dx, dy] = worldToCanvas(agent.destination.x, agent.destination.y);
      ctx.strokeStyle = color + '33';
      ctx.setLineDash([4, 4]);
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(ax, ay);
      ctx.lineTo(dx, dy);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    // selected highlight
    if (selectedAgentId === agent.id) {
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(ax, ay, radius + 4, 0, Math.PI * 2);
      ctx.stroke();
    }

    // vision radius on hover
    if (hoveredAgent && hoveredAgent.id === agent.id) {
      const vr = getVisionRadius(agent) * scale;
      ctx.strokeStyle = color + '22';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(ax, ay, vr, 0, Math.PI * 2);
      ctx.stroke();
    }

    // disconnected indicator
    if (!agent.isConnected) {
      ctx.globalAlpha = 0.4;
    }

    // body
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(ax, ay, radius, 0, Math.PI * 2);
    ctx.fill();

    ctx.globalAlpha = 1;

    // label
    ctx.fillStyle = color;
    ctx.font = '9px JetBrains Mono';
    ctx.textAlign = 'center';
    ctx.fillText(agent.name, ax, ay - radius - 3);
  }

  requestAnimationFrame(render);
}

function getVisionRadius(agent) {
  if (agent.role === 'merchant') return 80;
  if (agent.role === 'fighter') return 100;
  if (agent.role === 'monster') {
    if (agent.evolutionStage >= 4) return 250;
    if (agent.evolutionStage >= 3) return 200;
    return 150;
  }
  return 100;
}

// === HOVER + CLICK ===
canvas.addEventListener('mousemove', (e) => {
  const rect = canvas.getBoundingClientRect();
  mouseX = e.clientX - rect.left;
  mouseY = e.clientY - rect.top;

  if (!state) return;

  const worldX = mouseX / scale;
  const worldY = mouseY / scale;

  let closest = null;
  let closestDist = Infinity;

  for (const a of state.agents) {
    const d = Math.hypot(a.position.x - worldX, a.position.y - worldY);
    if (d < 15 && d < closestDist) {
      closestDist = d;
      closest = a;
    }
  }

  hoveredAgent = closest;
  const tooltip = document.getElementById('tooltip');

  if (closest) {
    const hp = closest.health;
    const mhp = closest.maxHealth;
    const txt = [
      `${closest.name} (${closest.role})`,
      `HP: ${Math.round(hp)}/${mhp}  ATK: ${closest.attack}  DEF: ${closest.defense}`,
      `Gold: ${Math.round(closest.gold)}  Items: ${closest.inventory.length}`,
      `Pos: (${Math.round(closest.position.x)}, ${Math.round(closest.position.y)})`,
      closest.alliance ? `Alliance: ${closest.alliance}` : '',
      closest.role === 'monster' ? `Kills: ${closest.kills}  Stage: ${closest.evolutionStage}` : '',
    ].filter(Boolean).join('\n');

    tooltip.textContent = txt;
    tooltip.style.display = 'block';

    const panel = document.getElementById('map-panel');
    const pr = panel.getBoundingClientRect();
    let tx = e.clientX - pr.left + 12;
    let ty = e.clientY - pr.top + 12;
    if (tx + 260 > pr.width) tx -= 280;
    if (ty + 100 > pr.height) ty -= 120;
    tooltip.style.left = tx + 'px';
    tooltip.style.top = ty + 'px';
  } else {
    tooltip.style.display = 'none';
  }
});

canvas.addEventListener('mouseleave', () => {
  hoveredAgent = null;
  document.getElementById('tooltip').style.display = 'none';
});

canvas.addEventListener('click', (e) => {
  if (!state) return;
  const rect = canvas.getBoundingClientRect();
  const wx = (e.clientX - rect.left) / scale;
  const wy = (e.clientY - rect.top) / scale;

  let closest = null;
  let closestDist = Infinity;
  for (const a of state.agents) {
    const d = Math.hypot(a.position.x - wx, a.position.y - wy);
    if (d < 20 && d < closestDist) { closestDist = d; closest = a; }
  }
  selectedAgentId = closest ? closest.id : null;
  updateAgentList();
});

// === UI UPDATES ===
function updateStats() {
  if (!state) return;
  const connectedCount = state.agents.filter(a => a.isConnected).length;
  const el = document.getElementById('stats-content');
  el.innerHTML = [
    row('Agents', `${connectedCount} connected / ${state.agents.length} total`),
    row('NPCs', state.npcMonsters.length),
    row('Trees', state.resourceCounts.trees),
    row('Gold veins', state.resourceCounts.goldVeins),
    row('Saplings', state.resourceCounts.saplings),
    row('Behemoths', state.behemoths.length),
  ].join('');
}

function row(label, value) {
  return `<div class="stat-row"><span class="stat-label">${label}</span><span>${value}</span></div>`;
}

function updateAgentList() {
  if (!state) return;
  const el = document.getElementById('agents-list');
  const headerEl = document.getElementById('agents-header');

  // Determine which agents to show and whether to show controls
  const showControls = !isGodMode && currentUser;
  const isAdmin = isGodMode || (currentUser && currentUser.is_admin);

  // Build set of user's owned agent names for matching with world agents
  const ownedAgentNames = new Set(myAgents.map(a => a.agent_name));
  const ownedAgentMap = {};
  for (const a of myAgents) {
    ownedAgentMap[a.agent_name] = a;
  }

  if (isAdmin) {
    headerEl.textContent = 'ALL AGENTS';
  } else if (currentUser) {
    const count = myAgents.length;
    const max = currentUser.max_agents;
    headerEl.textContent = `MY AGENTS (${count}/${max})`;
  }

  // sort: fighters, merchants, monsters
  const order = { fighter: 0, merchant: 1, monster: 2 };
  const sorted = [...state.agents].sort((a, b) => (order[a.role] ?? 3) - (order[b.role] ?? 3));

  el.innerHTML = sorted.map(a => {
    const color = ROLE_COLORS[a.role] || '#fff';
    const sel = selectedAgentId === a.id ? ' selected' : '';
    const hpBar = buildHealthBar(a.health, a.maxHealth);
    const posStr = `(${Math.round(a.position.x)}, ${Math.round(a.position.y)})`;
    const destStr = a.destination ? ` \u2192 (${Math.round(a.destination.x)}, ${Math.round(a.destination.y)})` : '';
    const allianceStr = a.alliance ? `\n  Alliance: ${esc(a.alliance)}` : '';
    const equipParts = [];
    if (a.equipment.weapon) equipParts.push(esc(a.equipment.weapon));
    if (a.equipment.armor) equipParts.push(esc(a.equipment.armor));
    if (a.equipment.tool) equipParts.push(esc(a.equipment.tool));
    const equipStr = equipParts.length > 0 ? `\n  Equip: ${equipParts.join(', ')}` : '';
    const monsterStr = a.role === 'monster' ? `  Kills: ${a.kills}  Stage: ${a.evolutionStage}` : '';
    const connIcon = a.isConnected ? '' : ' [DC]';
    const escapedId = esc(a.id);
    const escapedName = esc(a.name);

    // Show controls if this is the user's agent
    const dbAgent = ownedAgentMap[a.name];
    let controlsHtml = '';
    if (showControls && dbAgent) {
      const agentDbId = esc(dbAgent.id);
      if (dbAgent.status === 'running') {
        controlsHtml = `<div class="agent-controls"><button onclick="event.stopPropagation();stopAgent('${agentDbId}')">Stop</button></div>`;
      } else {
        controlsHtml = `<div class="agent-controls"><button onclick="event.stopPropagation();startAgent('${agentDbId}')">Start</button><button class="danger" onclick="event.stopPropagation();deleteAgent('${agentDbId}')">Delete</button></div>`;
      }
    } else if (isAdmin && !isGodMode && dbAgent) {
      // Admin also gets controls for all agents
      const agentDbId = esc(dbAgent.id);
      if (dbAgent.status === 'running') {
        controlsHtml = `<div class="agent-controls"><button onclick="event.stopPropagation();stopAgent('${agentDbId}')">Stop</button></div>`;
      } else {
        controlsHtml = `<div class="agent-controls"><button onclick="event.stopPropagation();startAgent('${agentDbId}')">Start</button><button class="danger" onclick="event.stopPropagation();deleteAgent('${agentDbId}')">Delete</button></div>`;
      }
    }

    // Cost info if available
    let costStr = '';
    if (dbAgent && dbAgent.total_cost > 0) {
      costStr = `\n  Cost: $${dbAgent.total_cost.toFixed(4)} (${dbAgent.total_llm_calls} calls)`;
    }

    return `<div class="agent-card${sel}" data-id="${escapedId}" onclick="selectAgent('${escapedId}')">
  <div class="agent-header">
    <span class="agent-name" style="color:${color}">${escapedName}${connIcon}</span>
    <span class="agent-status ${esc(a.status)}">[${esc(a.status.toUpperCase())}]</span>
  </div>
  <div class="agent-details">
    HP: ${hpBar} ${Math.round(a.health)}/${a.maxHealth}
    ATK: ${a.attack}  DEF: ${a.defense}  SPD: ${a.speed}
    Gold: ${Math.round(a.gold)}${monsterStr}
    Pos: ${posStr}${destStr}${allianceStr}${equipStr}${costStr}
  </div>
  ${controlsHtml}
</div>`;
  }).join('');

  // Show stopped agents that aren't in the world yet
  if (showControls) {
    const worldAgentNames = new Set(state.agents.map(a => a.name));
    const stoppedAgents = myAgents.filter(a => !worldAgentNames.has(a.agent_name));
    for (const a of stoppedAgents) {
      const agentDbId = esc(a.id);
      const roleColor = ROLE_COLORS[a.agent_role] || '#fff';
      el.innerHTML += `<div class="agent-card">
  <div class="agent-header">
    <span class="agent-name" style="color:${roleColor}">${esc(a.agent_name)}</span>
    <span class="agent-status" style="color:#555">[${esc(a.status.toUpperCase())}]</span>
  </div>
  <div class="agent-details" style="color:var(--text-secondary)">
    Role: ${esc(a.agent_role)}${a.total_cost > 0 ? `  Cost: $${a.total_cost.toFixed(4)}` : ''}
  </div>
  <div class="agent-controls">
    <button onclick="event.stopPropagation();startAgent('${agentDbId}')">Start</button>
    <button class="danger" onclick="event.stopPropagation();deleteAgent('${agentDbId}')">Delete</button>
  </div>
</div>`;
    }
  }
}

function selectAgent(id) {
  selectedAgentId = selectedAgentId === id ? null : id;
  updateAgentList();
}

function buildHealthBar(hp, maxHp) {
  const total = 10;
  const filled = Math.round((hp / maxHp) * total);
  const f = '\u2588'.repeat(Math.max(0, filled));
  const e = '\u2591'.repeat(Math.max(0, total - filled));
  return `<span class="health-bar"><span class="filled">${f}</span><span class="empty">${e}</span></span>`;
}

// === EVENT FEED ===
function updateEventFeed(events, messages, tick) {
  if (!state) return;

  // process world events
  for (const ev of events) {
    const line = formatEvent(ev, tick);
    if (line) eventLog.push(line);
  }

  // process chat messages
  for (const msg of messages) {
    const modeTag = msg.mode === 'broadcast' ? 'broadcast' : msg.mode === 'whisper' ? 'whisper' : 'local';
    eventLog.push({
      tick,
      cls: 'event-chat',
      text: `\uD83D\uDCAC ${esc(msg.senderName)} [${modeTag}]: "${esc(truncate(msg.content, 50))}"`,
    });
  }

  // trim
  while (eventLog.length > MAX_EVENTS) eventLog.shift();

  // render
  const el = document.getElementById('events-list');
  el.innerHTML = eventLog.map(e =>
    `<div class="event-line ${e.cls}"><span class="event-tick">[${e.tick}]</span> ${e.text}</div>`
  ).join('');

  // auto-scroll
  const feed = document.getElementById('event-feed');
  feed.scrollTop = feed.scrollHeight;
}

function formatEvent(ev, tick) {
  const agentName = (id) => {
    if (!state) return esc(id);
    const a = state.agents.find(a => a.id === id);
    return a ? esc(a.name) : esc(id);
  };

  switch (ev.type) {
    case 'combat_hit':
      return { tick, cls: 'event-combat', text: `\u2694\uFE0F ${agentName(ev.attackerId)} hit ${agentName(ev.targetId)} for ${ev.damage} dmg (${Math.round(ev.targetHealthAfter)} HP left)` };
    case 'death':
      return { tick, cls: 'event-death', text: `\uD83D\uDC80 ${agentName(ev.entityId)} was killed${ev.killedBy ? ' by ' + agentName(ev.killedBy) : ''} (+${ev.droppedGold} gold dropped)` };
    case 'respawn':
      return { tick, cls: 'event-spawn', text: `\u2728 ${agentName(ev.agentId)} respawned` };
    case 'evolution':
      return { tick, cls: 'event-evolution', text: `\u26A1 ${agentName(ev.monsterId)} evolved to Stage ${ev.toStage}!` };
    case 'resource_gathered':
      return { tick, cls: 'event-resource', text: `\u26CF\uFE0F ${agentName(ev.agentId)} gathered ${ev.quantity} ${esc(ev.item)}` };
    case 'resource_depleted':
      return { tick, cls: 'event-resource', text: `\uD83E\uDEA8 Resource depleted at (${Math.round(ev.position.x)}, ${Math.round(ev.position.y)})` };
    case 'tree_planted':
      return { tick, cls: 'event-resource', text: `\uD83C\uDF31 ${agentName(ev.agentId)} planted a tree seed` };
    case 'tree_grown':
      return { tick, cls: 'event-resource', text: `\uD83C\uDF33 A tree has grown at (${Math.round(ev.position.x)}, ${Math.round(ev.position.y)})` };
    case 'trade_complete':
      return { tick, cls: 'event-trade', text: `\uD83D\uDD04 ${agentName(ev.buyer)} traded with ${agentName(ev.seller)}` };
    case 'craft_complete':
      return { tick, cls: 'event-trade', text: `\uD83D\uDD28 ${agentName(ev.agentId)} crafted ${esc(ev.item)}` };
    case 'behemoth_knockout':
      return { tick, cls: 'event-behemoth', text: `\uD83C\uDFD4\uFE0F Behemoth knocked unconscious!` };
    case 'behemoth_wake':
      return { tick, cls: 'event-behemoth', text: `\uD83C\uDFD4\uFE0F Behemoth woke up! ${ev.thrownOff.length} thrown off` };
    case 'alliance_formed':
      return { tick, cls: 'event-alliance', text: `\uD83C\uDFF0 ${agentName(ev.founder)} formed alliance "${esc(ev.name)}"` };
    case 'alliance_joined':
      return { tick, cls: 'event-alliance', text: `\uD83C\uDFF0 ${agentName(ev.agentId)} joined alliance "${esc(ev.name)}"` };
    case 'npc_spawn':
      return { tick, cls: 'event-spawn', text: `\uD83D\uDC7E NPC ${esc(ev.template)} spawned` };
    case 'monster_eat':
      return { tick, cls: 'event-combat', text: `\uD83C\uDF56 ${agentName(ev.eaterId)} devoured ${agentName(ev.eatenId)}` };
    default:
      return null;
  }
}

function truncate(str, len) {
  return str.length > len ? str.slice(0, len) + '...' : str;
}

// === WEBSOCKET ===
let ws = null;
let agentPollInterval = null;

function connectWs() {
  const proto = location.protocol === 'https:' ? 'wss' : 'ws';
  let wsUrl;

  if (isGodMode) {
    const params = new URLSearchParams(location.search);
    const key = params.get('key') || '';
    wsUrl = `${proto}://${location.host}/ws?key=${encodeURIComponent(key)}`;
  } else {
    wsUrl = `${proto}://${location.host}/ws?token=${encodeURIComponent(authToken)}`;
  }

  ws = new WebSocket(wsUrl);

  ws.onopen = () => {
    document.getElementById('conn-dot').classList.add('connected');
    document.getElementById('conn-label').textContent = 'connected';
    // Poll agents periodically to keep controls in sync
    if (!isGodMode && authToken) {
      if (agentPollInterval) clearInterval(agentPollInterval);
      agentPollInterval = setInterval(fetchMyAgents, 10000);
    }
  };

  ws.onmessage = (event) => {
    const data = JSON.parse(event.data);
    if (data.type === 'admin_tick') {
      state = data;
      document.getElementById('tick-display').textContent = `Tick: ${data.tick}`;
      updateStats();
      updateAgentList();
      updateEventFeed(data.events || [], data.messages || [], data.tick);
    }
  };

  ws.onclose = () => {
    document.getElementById('conn-dot').classList.remove('connected');
    document.getElementById('conn-label').textContent = 'disconnected';
    if (agentPollInterval) {
      clearInterval(agentPollInterval);
      agentPollInterval = null;
    }
    // Only reconnect if we still have auth
    if (authToken || isGodMode) {
      setTimeout(connectWs, 2000);
    }
  };

  ws.onerror = () => {
    ws.close();
  };
}

// Hide spawn form for god-mode
if (isGodMode) {
  const sf = document.getElementById('spawn-form');
  if (sf) sf.style.display = 'none';
}
</script>
</body>
</html>
